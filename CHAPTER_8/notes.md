# 第八章 函数探幽
## 8.1 C++内联函数
作用：对于内联函数代码，程序无需跳到另一个位置处执行存放在此处的函数代码，再跳回函数调用处，但代价是需要占用更多内存。

用法：通常的做法是省略原型，将整个定义（函数头加函数体）放在本应提供原型的地方,并在前加inline。例：`inline double square(double x){return x*x;}`

内联函数不能递归 ，内联函数按值传递参数。

## 8.2 引用变量
作用：引用是已定义变量的别名，通过将引用变量用作参数，函数将使用原始数据。
### 8.2.1 创建引用变量
```
int rats;
int &rodents = rats;
```
上述引用声明允许rats和rodents指向相同的值和内存单元。
注意不要将引用&与地址运算符&混淆。

引用与指针的区别：必须在声明引用变量时进行初始化，但指针可以先声明再赋值。
`int & rodents = rats;`与`int * const pr = &rats;`等价；

可以通过初始化声明来设置引用，但不能通过赋值来设置（不能将其他变量赋给已经初始化的引用变量，引用变量一旦与某个变量关联起来，就将一直效忠于它）。

按值传递的函数，实参的限制很小，可以是常量，变量，表达式等等，但传递引用的限制比较严格。如果实参与引用参数不匹配，c++将生成临时变量（仅当参数引用为const时），因为临时变量仍旧是按值传递的，并不能实现引用的最初意图。
### 8.2.2 将引用用作函数参数
引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量。`void func(int &a,int &b);`改变被调用函数中的a b能够改变调用函数中的变量。

c语言使用按指针传递的方式避开按值传递的限制。
### 8.2.4将引用用于结构
```
struct a{int num};
void func1(const a & ft);//引用结构作为函数参数，并不改变结构本身。
a & func2(a & ft);//引用结构作为函数参数，并返回引用。
```
返回引用的函数实际上是被引用的变量的别名。返回引用一定要注意，避免返回函数终止时不再存在的内存单元引用，如下述错误：
```
const free_throws & clone(free_throws & ft)
{
   free_throws newguy;
   newguy = ft;
   return newguy;
}
```
## 8.3 默认参数
函数调用中省略了实参时自动使用的一个值。

默认参数必须通过函数原型来设置，函数定义不做修改，`char * left(const char * str, int n =1 )`，使用该函数时如果省略了参数n，则默认为1，若不省略，传递的值将覆盖1.

必须从右向左添加默认值，使用时实参按从左到右的顺序依次被赋给相应的形参，不能跳过任何参数。



