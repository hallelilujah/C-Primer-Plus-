# 第八章 函数探幽
## 8.1 C++内联函数
作用：对于内联函数代码，程序无需跳到另一个位置处执行存放在此处的函数代码，再跳回函数调用处，但代价是需要占用更多内存。

用法：通常的做法是省略原型，将整个定义（函数头加函数体）放在本应提供原型的地方,并在前加inline。例：`inline double square(double x){return x*x;}`

内联函数不能递归 ，内联函数按值传递参数。

## 8.2 引用变量
作用：引用是已定义变量的别名，通过将引用变量用作参数，函数将使用原始数据。
### 8.2.1 创建引用变量
```
int rats;
int &rodents = rats;
```
上述引用声明允许rats和rodents指向相同的值和内存单元。
注意不要将引用&与地址运算符&混淆。

引用与指针的区别：必须在声明引用变量时进行初始化，但指针可以先声明再赋值。
`int & rodents = rats;`与`int * const pr = &rats;`等价；

可以通过初始化声明来设置引用，但不能通过赋值来设置（不能将其他变量赋给已经初始化的引用变量，引用变量一旦与某个变量关联起来，就将一直效忠于它）。

按值传递的函数，实参的限制很小，可以是常量，变量，表达式等等，但传递引用的限制比较严格。如果实参与引用参数不匹配，c++将生成临时变量（仅当参数引用为const时），因为临时变量仍旧是按值传递的，并不能实现引用的最初意图。
### 8.2.2 将引用用作函数参数
引用经常被用作函数参数，使得函数中的变量名成为调用程序中的变量的别名。这种传递参数的方法称为按引用传递。按引用传递允许被调用的函数能够访问调用函数中的变量。`void func(int &a,int &b);`改变被调用函数中的a b能够改变调用函数中的变量。

c语言使用按指针传递的方式避开按值传递的限制。
### 8.2.4将引用用于结构
```
struct a{int num};
void func1(const a & ft);//引用结构作为函数参数，并不改变结构本身。
a & func2(a & ft);//引用结构作为函数参数，并返回引用。
```
返回引用的函数实际上是被引用的变量的别名。返回引用一定要注意，避免返回函数终止时不再存在的内存单元引用，如下述错误：
```
const free_throws & clone(free_throws & ft)
{
   free_throws newguy;
   newguy = ft;
   return newguy;
}
```
## 8.3 默认参数
函数调用中省略了实参时自动使用的一个值。

默认参数必须通过函数原型来设置，函数定义不做修改，`char * left(const char * str, int n =1 )`，使用该函数时如果省略了参数n，则默认为1，若不省略，传递的值将覆盖1.

必须从右向左添加默认值，使用时实参按从左到右的顺序依次被赋给相应的形参，不能跳过任何参数。
## 8.4 函数重载
函数多态（函数重载）让用户能够使用多个同名的函数。

函数重载的关键是函数的参数列表，也称为函数特征标，如果两个函数的参数数目和类型相同，同时参数的排列顺序也相同，则它们的特征标相同，而变量名是无关紧要的。
c++允许定义名称相同的函数，条件是它们的特征标不同，函数返回类型可以相同也可以不同，重要的是特征标。

编译器在检查函数特征标时，将把类型引用和类型本身视为同一个特征标。

仅当函数基本上执行相同的任务，但使用不同形式的数据时，才应采用函数重载。
## 8.5 函数模板
所谓函数模板，实际上是建立一个通用函数，它所用到的数据的类型（包括返回值类型、形参类型、局部变量类型）可以不具体指定，而是用一个虚拟的类型来代替（实际上是用一个标识符来占位），等发生函数调用时再根据传入的实参来逆推出真正的类型。这个通用函数就称为函数模板（Function Template）。

在函数模板中，数据的值和类型都被参数化了，发生函数调用时编译器会根据传入的实参来推演形参的值和类型。换个角度说，函数模板除了支持值的参数化，还支持类型的参数化。

一但定义了函数模板，就可以将类型参数用于函数定义和函数声明了。说得直白一点，原来使用 int、float、char 等内置类型的地方，都可以用类型参数来代替。

把处理不同类型的公共逻辑抽象成函数，就得到了函数模板。

模板定义本身不参与编译，而是编译器根据模板的用户使用模板时提供的类型参数生成代码，再进行编译，这一过程被称为模板实例化。用户提供不同的类型参数，就会实例化出不同的代码。
```
template <typename anytype>
void swap(anytype &a, anytype &b)
{
anytype temp;
temp=a;
a=b;
b=temp;
}
```
template是定义函数模板的关键字，它后面紧跟尖括号<>，尖括号包围的是类型参数（也可以说是虚拟的类型，或者说是类型占位符）。typename是另外一个关键字，用来声明具体的类型参数，这里的类型参数就是T。从整体上看，template<typename T>被称为模板头。
模板头中包含的类型参数可以用在函数定义的各个位置，包括返回值、形参列表和函数体；本例我们在形参列表和函数体中使用了类型参数T。
类型参数的命名规则跟其他标识符的命名规则一样，不过使用 T、T1、T2、Type 等已经成为了一种惯例。类型参数可以有多个，它们之间以逗号,分隔。类型参数列表以< >包围，形式参数列表以( )包围。
   
更常见的情形是，将模板放在头文件中，并在需要使用模板的文件中包含头文件。
模板也可以重载定义，被重载的模板的函数特征标必须不同。


