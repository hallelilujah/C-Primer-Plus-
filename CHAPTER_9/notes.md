# 第九章 内存模型和名称空间
## 9.1 单独编译
C++允许甚至鼓励程序员将组件函数放在独立的文件中，可以单独编译这些文件，然后将它们链接成可执行的程序。

头文件中常包含的内容：函数原型、使用#define或const定义的符号常量、结构声明、类声明、模板声明、内联函数。
不要将函数定义或变量声明放到头文件中。在包含自己的头文件时，应使用引号而不是尖括号。

#ifndef与#endif
## 9.2 存储持续性、作用域和链接性
存储数据的方案：
1. 自动存储持续性：在函数定义中声明的变量（包括函数参数）的存储持续性为自动的。在函数或代码块开始执行时被创建，执行完后其使用的内存被释放。作用域为局部，没有链接性。
2. 静态存储持续性：在函数定义外定义的变量和使用关键字static定义的变量存储持续性为静态，在程序整个运行过程中都存在。有外部链接性、内部链接性（static函数外）、无链接性（static函数内）。
3. 线程存储持续性：并行编程。
4. 动态存储持续性：自由存储（堆）。

静态持续性中的外部链接性：定义声明（定义）给变量分配存储空间，引用声明使用关键字extern，且不进行初始化。（单定义规则）

静态持续性中的内部链接性：将static限定符用于作用域为整个文件的变量时，该变量的链接性将为内部的。如果将作用域为整个文件的变量变为静态的，就不必担心其名称与其他文件中的作用域为整个文件的变量发生冲突。

静态持续性中的无链接性：将static限定符用于在代码块中定义的变量，虽然该变量只在该代码块中可用，但它在该代码块不处于活动状态时仍然存在。如果初始化了静态局部变量，则程序只在启动时进行一次初始化，以后再调用函数时，将不会像自动变量那样再次被初始化。

## 9.3名称空间
功能：控制名称的作用域

声明区域：例如，在函数外面声明全局变量，其声明区域为其声明所在的文件；在函数中的变量，其声明区域为其声明所在的代码块。

潜在作用域：从声明点开始，到其声明区域的结尾。

作用域：变量对程序而言可见的范围。

每个声明区域都可以声明名称，这些名称独立于在其他声明区域中声明的名称。C++通过定义一种新的声明区域来创建命名的名称空间，名称空间可以是全局的，也可以位于另一个名称空间中，但不能位于代码块中，默认在名称空间中声明的名称的链接性为外部的，任何名称空间中的名称都不会与其他名称空间中的名称发生冲突，名称空间是开放的。
```
namespace jack{
double pail；
void fetch（）；
}
```
访问给定名称空间中的名称--作用域解析运算符::`jack pail=12.34;`
